import { Value } from "ox";
import * as ox__AbiFunction from "ox/AbiFunction";
import { Transfer } from "../../bridge/index.js";
import { getCachedChain } from "../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../constants/addresses.js";
import { getContract } from "../../contract/contract.js";
import { decimals } from "../../extensions/erc20/read/decimals.js";
/**
 * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.
 * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.
 *
 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
 * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)
 * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoTransfer } from "thirdweb/pay";
 *
 * const transfer = await getBuyWithCryptoTransfer({
 *  client,
 *  fromAddress: "0x...", // wallet address
 *  toAddress: "0x...", // recipient address - likely to be your wallet
 *  chainId: 10, // chain id of the token
 *  tokenAddress: "0x...", // address of the token
 *  amount: "10", // amount of token to transfer
 *  purchaseData: {  // any metadata for you to attribute this purchase
 *    "customerId": "yourId"
 *  }
 * });
 * ```
 * @deprecated
 * @buyCrypto
 */
export async function getBuyWithCryptoTransfer(params) {
    try {
        const tokenContract = getContract({
            address: params.tokenAddress,
            chain: getCachedChain(params.chainId),
            client: params.client,
        });
        const tokenDecimals = tokenContract.address.toLowerCase() === NATIVE_TOKEN_ADDRESS
            ? 18
            : await decimals({
                contract: tokenContract,
            });
        const amount = Value.from(params.amount, tokenDecimals);
        const quote = await Transfer.prepare({
            chainId: params.chainId,
            tokenAddress: params.tokenAddress,
            amount,
            sender: params.fromAddress,
            receiver: params.toAddress,
            client: params.client,
            feePayer: params.feePayer,
            paymentLinkId: params.paymentLinkId,
            purchaseData: params.purchaseData,
        });
        const firstStep = quote.steps[0];
        if (!firstStep) {
            throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
        }
        const approvalTxs = firstStep.transactions.filter((tx) => tx.action === "approval");
        if (approvalTxs.length > 1) {
            throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
        }
        const approvalTx = approvalTxs[0];
        let approvalData;
        if (approvalTx) {
            const abiFunction = ox__AbiFunction.from([
                "function approve(address spender, uint256 amount)",
            ]);
            const [spender, amount] = ox__AbiFunction.decodeData(abiFunction, approvalTx.data);
            approvalData = {
                chainId: firstStep.originToken.chainId,
                tokenAddress: firstStep.originToken.address,
                spenderAddress: spender,
                amountWei: amount.toString(),
            };
        }
        const txs = firstStep.transactions.filter((tx) => tx.action !== "approval");
        if (txs.length > 1) {
            throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
        }
        const tx = txs[0];
        if (!tx) {
            throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
        }
        const transfer = {
            transactionRequest: {
                ...tx,
                extraGas: 50000n, // extra gas buffer
            },
            approvalData,
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            paymentToken: {
                token: {
                    tokenAddress: firstStep.originToken.address,
                    chainId: firstStep.originToken.chainId,
                    decimals: firstStep.originToken.decimals,
                    symbol: firstStep.originToken.symbol,
                    name: firstStep.originToken.name,
                    priceUSDCents: firstStep.originToken.priceUsd * 100,
                },
                amountWei: quote.originAmount.toString(),
                amount: Value.format(quote.originAmount, firstStep.originToken.decimals).toString(),
                amountUSDCents: Number(Value.format(quote.originAmount, firstStep.originToken.decimals)) *
                    firstStep.originToken.priceUsd *
                    100,
            },
            processingFee: {
                token: {
                    tokenAddress: firstStep.originToken.address,
                    chainId: firstStep.originToken.chainId,
                    decimals: firstStep.originToken.decimals,
                    symbol: firstStep.originToken.symbol,
                    name: firstStep.originToken.name,
                    priceUSDCents: firstStep.originToken.priceUsd * 100,
                },
                amountWei: params.feePayer === "sender"
                    ? (quote.originAmount - quote.destinationAmount).toString()
                    : "0",
                amount: params.feePayer === "sender"
                    ? Value.format(quote.originAmount - quote.destinationAmount, firstStep.originToken.decimals).toString()
                    : "0",
                amountUSDCents: params.feePayer === "sender"
                    ? Number(Value.format(quote.originAmount - quote.destinationAmount, firstStep.originToken.decimals)) *
                        firstStep.originToken.priceUsd *
                        100
                    : 0,
            },
            estimatedGasCostUSDCents: 0,
            client: params.client,
        };
        return transfer;
    }
    catch (error) {
        console.error("Error getting buy with crypto transfer", error);
        throw error;
    }
}
//# sourceMappingURL=getTransfer.js.map