"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBuySupportedDestinations = useBuySupportedDestinations;
exports.useBuySupportedSources = useBuySupportedSources;
const react_query_1 = require("@tanstack/react-query");
const ox_1 = require("ox");
const Bridge = require("../../../../../../../bridge/index.js");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const withCache_js_1 = require("../../../../../../../utils/promise/withCache.js");
async function fetchBuySupportedDestinations({ client, originChainId, originTokenAddress, }) {
    return (0, withCache_js_1.withCache)(async () => {
        const routes = await Bridge.routes({
            client,
            originChainId,
            originTokenAddress,
            maxSteps: 1,
            sortBy: "popularity",
            limit: 1_000_000,
        });
        const tokens = new Set();
        const chains = new Set();
        const destinationTokens = [];
        for (const route of routes) {
            const key = `${route.destinationToken.chainId}:${route.destinationToken.address}`;
            if (!tokens.has(key)) {
                tokens.add(key);
                if (!chains.has(route.destinationToken.chainId)) {
                    chains.add(route.destinationToken.chainId);
                }
                const existing = destinationTokens[route.destinationToken.chainId];
                if (!existing) {
                    destinationTokens[route.destinationToken.chainId] = [];
                }
                destinationTokens[route.destinationToken.chainId] = [
                    ...(existing || []),
                    {
                        address: ox_1.Address.checksum(route.destinationToken.address),
                        // We support both options for all tokens
                        buyWithCryptoEnabled: true,
                        buyWithFiatEnabled: true,
                        name: route.destinationToken.name,
                        symbol: route.destinationToken.symbol,
                        icon: route.destinationToken.iconUri,
                    },
                ];
            }
        }
        return [...chains].map((chainId) => ({
            chain: (0, utils_js_1.getCachedChain)(chainId),
            tokens: destinationTokens[chainId] || [],
        }));
    }, {
        cacheKey: `buy-supported-destinations-${originChainId}:${originTokenAddress}`,
        cacheTime: 5 * 60 * 1000,
    });
}
/**
 * @internal
 */
function useBuySupportedDestinations(client, _isTestMode) {
    return (0, react_query_1.useQuery)({
        queryKey: ["destination-tokens", client],
        queryFn: async () => {
            return fetchBuySupportedDestinations({ client });
        },
    });
}
function useBuySupportedSources(options) {
    return (0, react_query_1.useQuery)({
        queryKey: ["source-tokens", options],
        queryFn: async () => {
            const routes = await Bridge.routes({
                client: options.client,
                destinationChainId: options.destinationChainId,
                destinationTokenAddress: options.destinationTokenAddress,
                maxSteps: 1,
                sortBy: "popularity",
                limit: 50,
            });
            const tokens = new Set();
            const chains = new Set();
            const originTokens = [];
            for (const route of routes) {
                const key = `${route.originToken.chainId}:${route.originToken.address}`;
                if (!tokens.has(key)) {
                    tokens.add(key);
                    if (!chains.has(route.originToken.chainId)) {
                        chains.add(route.originToken.chainId);
                    }
                    const existing = originTokens[route.originToken.chainId];
                    if (!existing) {
                        originTokens[route.originToken.chainId] = [];
                    }
                    originTokens[route.originToken.chainId] = [
                        ...(existing || []),
                        {
                            address: ox_1.Address.checksum(route.originToken.address),
                            // We support both options for all tokens
                            buyWithCryptoEnabled: true,
                            buyWithFiatEnabled: true,
                            name: route.originToken.name,
                            symbol: route.originToken.symbol,
                            icon: route.originToken.iconUri,
                        },
                    ];
                }
            }
            return [...chains].map((chainId) => ({
                chain: (0, utils_js_1.getCachedChain)(chainId),
                tokens: originTokens[chainId] || [],
            }));
        },
    });
}
//# sourceMappingURL=useSwapSupportedChains.js.map