"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuyWithCryptoStatus = getBuyWithCryptoStatus;
const index_js_1 = require("../../bridge/index.js");
const units_js_1 = require("../../utils/units.js");
/**
 * Gets the status of a buy with crypto transaction
 * @param buyWithCryptoTransaction - Object of type [`BuyWithCryptoTransaction`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransaction)
 * @example
 *
 * ```ts
 * import { sendTransaction } from "thirdweb";
 * import { getBuyWithCryptoStatus, getBuyWithCryptoQuote } from "thirdweb/pay";
 *
 * // get a quote between two tokens
 * const quote = await getBuyWithCryptoQuote(quoteParams);
 *
 * // if approval is required, send the approval transaction
 * if (quote.approval) {
 *  const txResult = await sendTransaction({
 *    transaction: quote.approval,
 *    account: account, // account from connected wallet
 *  });
 *
 *  await waitForReceipt(txResult);
 * }
 *
 * // send the quoted transaction
 * const swapTxResult = await sendTransaction({
 *    transaction: quote.transactionRequest,
 *    account: account, // account from connected wallet
 *  });
 *
 * await waitForReceipt(swapTxResult);
 *
 * // keep polling the status of the quoted transaction until it returns a success or failure status
 * const status = await getBuyWithCryptoStatus({
 *    client,
 *    transactionHash: swapTxResult.transactionHash,
 * }});
 * ```
 * @returns Object of type [`BuyWithCryptoStatus`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoStatus)
 * @deprecated use Bridge.status instead
 * @buyCrypto
 */
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
    try {
        if (!buyWithCryptoTransaction.transactionHash) {
            throw new Error("Transaction hash is required");
        }
        const result = await (0, index_js_1.status)({
            transactionHash: buyWithCryptoTransaction.transactionHash,
            chainId: buyWithCryptoTransaction.chainId,
            client: buyWithCryptoTransaction.client,
        });
        switch (result.status) {
            case "COMPLETED": {
                const originTransaction = result.transactions?.find((tx) => tx.chainId === buyWithCryptoTransaction.chainId);
                const destinationTransaction = result.transactions?.find((tx) => tx.chainId !== buyWithCryptoTransaction.chainId);
                return toBuyWithCryptoStatus({
                    originTransaction,
                    destinationTransaction,
                    originAmount: result.originAmount,
                    destinationAmount: result.destinationAmount,
                    originTokenAddress: result.originTokenAddress,
                    destinationTokenAddress: result.destinationTokenAddress,
                    originChainId: result.originChainId,
                    destinationChainId: result.destinationChainId,
                    status: result.status,
                    sender: result.sender,
                    receiver: result.receiver,
                    paymentId: result.paymentId,
                    originToken: result.originToken,
                    destinationToken: result.destinationToken,
                    purchaseData: result.purchaseData,
                });
            }
            case "PENDING": {
                return toBuyWithCryptoStatus({
                    originAmount: result.originAmount,
                    originTokenAddress: result.originTokenAddress,
                    destinationTokenAddress: result.destinationTokenAddress,
                    originChainId: result.originChainId,
                    destinationChainId: result.destinationChainId,
                    status: result.status,
                    sender: result.sender,
                    receiver: result.receiver,
                    paymentId: result.paymentId,
                    originToken: result.originToken,
                    destinationToken: result.destinationToken,
                    purchaseData: result.purchaseData,
                });
            }
            case "FAILED": {
                const originTransaction = result.transactions?.find((tx) => tx.chainId === buyWithCryptoTransaction.chainId);
                const destinationTransaction = result.transactions?.find((tx) => tx.chainId !== buyWithCryptoTransaction.chainId);
                return toBuyWithCryptoStatus({
                    originTransaction,
                    destinationTransaction,
                    originAmount: BigInt(0), // TODO: get from API
                    originTokenAddress: "", // TODO: get from API
                    destinationTokenAddress: "", // TODO: get from API
                    originChainId: 0, // TODO: get from API
                    destinationChainId: 0, // TODO: get from API
                    status: result.status,
                    sender: "",
                    receiver: "",
                    paymentId: "",
                    originToken: undefined,
                    destinationToken: undefined,
                    purchaseData: result.purchaseData,
                });
            }
            default: {
                return {
                    status: "NOT_FOUND",
                };
            }
        }
    }
    catch (error) {
        console.error("Fetch error:", error);
        throw new Error(`Fetch failed: ${error}`);
    }
}
function toBuyWithCryptoStatus(args) {
    const { originTransaction, destinationTransaction, status, purchaseData, originAmount, destinationAmount, originTokenAddress, destinationTokenAddress, originChainId, destinationChainId, sender, receiver, originToken, destinationToken, } = args;
    return {
        fromAddress: sender,
        toAddress: receiver,
        quote: {
            createdAt: new Date().toISOString(),
            estimated: {
                fromAmountUSDCents: 0,
                toAmountMinUSDCents: 0,
                toAmountUSDCents: 0,
                slippageBPS: 0,
                feesUSDCents: 0,
                gasCostUSDCents: 0,
                durationSeconds: 0,
            },
            fromAmount: originToken
                ? (0, units_js_1.toTokens)(originAmount, originToken.decimals).toString()
                : "",
            fromAmountWei: originAmount.toString(),
            toAmount: destinationToken && destinationAmount
                ? (0, units_js_1.toTokens)(destinationAmount, destinationToken.decimals).toString()
                : "",
            toAmountWei: destinationAmount ? destinationAmount.toString() : "",
            toAmountMin: destinationToken
                ? (0, units_js_1.toTokens)(destinationAmount ?? BigInt(0), destinationToken.decimals).toString()
                : "",
            toAmountMinWei: destinationAmount ? destinationAmount.toString() : "",
            fromToken: {
                tokenAddress: originTokenAddress,
                chainId: originChainId,
                decimals: originToken?.decimals ?? 18,
                name: originToken?.name ?? "",
                symbol: originToken?.symbol ?? "",
                priceUSDCents: 0,
            },
            toToken: {
                tokenAddress: destinationTokenAddress,
                chainId: destinationChainId,
                decimals: destinationToken?.decimals ?? 18,
                name: destinationToken?.name ?? "",
                symbol: destinationToken?.symbol ?? "",
                priceUSDCents: 0,
            },
        },
        swapType: originTransaction?.chainId === destinationTransaction?.chainId
            ? "SAME_CHAIN"
            : "CROSS_CHAIN", // TODO transfer type?
        status: status,
        subStatus: status === "COMPLETED" ? "SUCCESS" : "NONE",
        purchaseData: purchaseData,
        bridge: "STARPORT",
        destination: {
            amount: destinationToken
                ? (0, units_js_1.toTokens)(destinationAmount ?? BigInt(0), destinationToken.decimals).toString()
                : "",
            amountWei: destinationAmount?.toString() ?? "",
            token: {
                tokenAddress: destinationTokenAddress,
                chainId: destinationChainId,
                decimals: destinationToken?.decimals ?? 18,
                name: destinationToken?.name ?? "",
                symbol: destinationToken?.symbol ?? "",
                priceUSDCents: 0,
            },
            amountUSDCents: 0,
            completedAt: new Date().toISOString(),
            explorerLink: "",
            transactionHash: destinationTransaction?.transactionHash ?? "",
        },
        source: {
            amount: originToken
                ? (0, units_js_1.toTokens)(originAmount, originToken.decimals).toString()
                : "",
            amountWei: originAmount.toString(),
            token: {
                tokenAddress: originTokenAddress,
                chainId: originChainId,
                decimals: originToken?.decimals ?? 18,
                name: originToken?.name ?? "",
                symbol: originToken?.symbol ?? "",
                priceUSDCents: 0,
            },
            amountUSDCents: 0,
            completedAt: new Date().toISOString(),
            explorerLink: "",
            transactionHash: originTransaction?.transactionHash ?? "",
        },
    };
}
//# sourceMappingURL=getStatus.js.map